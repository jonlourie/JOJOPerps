// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.19;

import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "IDealer.sol";
import "IPerpetual.sol";

contract JOJOTrader is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    IDealer public jojoDealer;
    IPerpetual public perpetualContract;
    IERC20Upgradeable public primaryAsset;  // e.g., USDC
    IERC20Upgradeable public secondaryAsset; // Optional e.g., JUSD if needed

    // This replaces the constructor for upgradeable contracts
    function initialize(
        address _jojoDealer,
        address _perpetualContract,
        address _primaryAsset,
        address initialOwner
    ) initializer public {
        __UUPSUpgradeable_init();
        
        jojoDealer = IDealer(_jojoDealer);
        perpetualContract = IPerpetual(_perpetualContract);
        primaryAsset = IERC20Upgradeable(_primaryAsset);

        transferOwnership(initialOwner);
    }

    // Approve JOJODealer to use tokens on behalf of the user
    function approvePrimaryAsset(uint256 amount) external {
        primaryAsset.approve(address(jojoDealer), amount);
    }

    // Deposit funds to JOJODealer
    function deposit(uint256 primaryAmount, uint256 secondaryAmount) external {
        jojoDealer.deposit(primaryAmount, secondaryAmount, address(this));
    }

    // Encode the order into bytes for trading
    function encodeOrder(
        address perp,            // Address of the perpetual market (e.g., BTC/USDC)
        int128 paperAmount,      // Long position (positive value)
        int128 creditAmount,     // Amount of collateral (USDC)
        bytes32 info             // Additional information (can be empty if not needed)
    ) public view returns (bytes memory) {
        return abi.encode(
            perp,
            address(this),        // Address of this contract acting as the trader
            paperAmount,          // Amount of the asset in position (e.g., 1 BTC)
            creditAmount,         // Credit amount (e.g., 30,000 USDC)
            info                  // Additional trade info
        );
    }

    // Open a long position by interacting with Perpetual.sol
    function openLongPosition(
        int128 paperAmount,   // e.g., 1 BTC
        int128 creditAmount   // e.g., 30,000 USDC
    ) external {
        // Create trade data
        bytes memory tradeData = encodeOrder(
            address(perpetualContract),   // The perpetual contract
            paperAmount,                  // Paper amount for the long position
            creditAmount,                 // Credit amount as collateral (USDC)
            bytes32(0)                    // Empty info for this example
        );

        // Execute the trade on the Perpetual contract
        perpetualContract.trade(tradeData);
    }

    // Close the long position by reversing the trade (negative paper amount)
    function closeLongPosition(
        int128 paperAmount,   // Should be negative of the amount used to open the position
        int128 creditAmount
    ) external {
        // Create trade data to close the position
        bytes memory tradeData = encodeOrder(
            address(perpetualContract),   // The perpetual contract
            -paperAmount,                 // Negative paper amount to close the long
            creditAmount,                 // Same credit amount (or whatever matches your setup)
            bytes32(0)                    // Empty info for this example
        );

        // Execute the trade to close the position
        perpetualContract.trade(tradeData);
    }

    // Request withdrawal (pending)
    function requestWithdraw(uint256 primaryAmount, uint256 secondaryAmount) external {
        jojoDealer.requestWithdraw(address(this), primaryAmount, secondaryAmount);
    }

    // Execute withdrawal after timelock
    function executeWithdraw(bool isInternal, bytes memory param) external {
        jojoDealer.executeWithdraw(address(this), msg.sender, isInternal, param);
    }

    // Fast withdrawal (no timelock)
    function fastWithdraw(
        uint256 primaryAmount,
        uint256 secondaryAmount,
        bool isInternal,
        bytes memory param
    ) external {
        jojoDealer.fastWithdraw(address(this), msg.sender, primaryAmount, secondaryAmount, isInternal, param);
    }

    // This function authorizes upgrades, only callable by the contract owner
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
}
